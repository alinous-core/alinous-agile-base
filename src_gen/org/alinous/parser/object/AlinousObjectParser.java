/* Generated By:JavaCC: Do not edit this line. AlinousObjectParser.java */
package org.alinous.parser.object;

import org.alinous.objects.Attribute;
import org.alinous.objects.IAttributeValue;
import org.alinous.objects.DqString;
import org.alinous.objects.SqString;
import org.alinous.objects.XMLTagBase;
import org.alinous.objects.html.ATagObject;
import org.alinous.objects.html.AddressTagObject;
import org.alinous.objects.html.AlinousTopObject;
import org.alinous.objects.html.AppletTagObject;
import org.alinous.objects.html.AreaTagObject;
import org.alinous.objects.html.BaseTagObject;
import org.alinous.objects.html.BgSoundObject;
import org.alinous.objects.html.BigTagObject;
import org.alinous.objects.html.BlockquoteTagObject;
import org.alinous.objects.html.ButtonTagObject;
import org.alinous.objects.html.CaptionTagObject;
import org.alinous.objects.html.CenterTagObject;
import org.alinous.objects.html.CiteTagObject;
import org.alinous.objects.html.ColTagObject;
import org.alinous.objects.html.ColgroupTagObject;
import org.alinous.objects.html.CommentObject;
import org.alinous.objects.html.DelTagObject;
import org.alinous.objects.html.DivTagObject;
import org.alinous.objects.html.DlTagObject;
import org.alinous.objects.html.DoctypeTagObject;
import org.alinous.objects.html.EmTagObject;
import org.alinous.objects.html.FieldsetTagObject;
import org.alinous.objects.html.FontTagObject;
import org.alinous.objects.html.FormTagObject;
import org.alinous.objects.html.FrameTagObject;
import org.alinous.objects.html.FramesetTagObject;
import org.alinous.objects.html.H4TagObject;
import org.alinous.objects.html.H5TagObject;
import org.alinous.objects.html.H6TagObject;
import org.alinous.objects.html.HeadTagObject;
import org.alinous.objects.html.HrTagObject;
import org.alinous.objects.html.HtmlTagObject;
import org.alinous.objects.html.ITagObject;
import org.alinous.objects.html.InputTagObject;
import org.alinous.objects.html.InsTagObject;
import org.alinous.objects.html.LabelTagObject;
import org.alinous.objects.html.LegendTagObject;
import org.alinous.objects.html.LiTagObject;
import org.alinous.objects.html.LinkTagObject;
import org.alinous.objects.html.MapTagObject;
import org.alinous.objects.html.MetaTagObject;
import org.alinous.objects.html.NoscriptTagObject;
import org.alinous.objects.html.ObjectTagObject;
import org.alinous.objects.html.OlTagObject;
import org.alinous.objects.html.OptgroupTagObject;
import org.alinous.objects.html.OptionTagObject;
import org.alinous.objects.html.ParamTagObject;
import org.alinous.objects.html.PreTagObject;
import org.alinous.objects.html.QTagObject;
import org.alinous.objects.html.ScriptTagObject;
import org.alinous.objects.html.SelectTagObject;
import org.alinous.objects.html.SmallTagObject;
import org.alinous.objects.html.SpanTagObject;
import org.alinous.objects.html.StyleTagObject;
import org.alinous.objects.html.SubTagObject;
import org.alinous.objects.html.SupTagObject;
import org.alinous.objects.html.TBodyTagObject;
import org.alinous.objects.html.TextAreaTagObject;
import org.alinous.objects.html.TfootTagObject;
import org.alinous.objects.html.ThTagObject;
import org.alinous.objects.html.ThreadTagObject;
import org.alinous.objects.html.TitleTag;
import org.alinous.objects.html.BodyTagObject;
import org.alinous.objects.html.TableTagObject;
import org.alinous.objects.html.TrTagObject;
import org.alinous.objects.html.TdTagObject;
import org.alinous.objects.html.BTagObject;
import org.alinous.objects.html.BrTagObject;
import org.alinous.objects.html.H1TagObject;
import org.alinous.objects.html.H2TagObject;
import org.alinous.objects.html.H3TagObject;
import org.alinous.objects.html.PTagObject;
import org.alinous.objects.html.ImgTagObject;
import org.alinous.objects.html.TtTagObject;
import org.alinous.objects.html.UlTagObject;
import org.alinous.objects.html.UnknownTagObject;
import org.alinous.objects.html.XmlHeaderTagObject;

import org.alinous.objects.html.StringContainer;


@SuppressWarnings({"unused", "rawtypes"})
public class AlinousObjectParser implements AlinousObjectParserConstants {
        public AlinousTopObject topObj = new AlinousTopObject();

  final public AlinousTopObject parse() throws ParseException {
        XMLTagBase header = null;
    label_1:
    while (true) {
      if (jj_2_1(2)) {
        ;
      } else {
        break label_1;
      }
      if (jj_2_2(2)) {
        header = docType();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TAG_BEGIN:
        case STR2TAG:
          header = xmlDef();
          break;
        default:
          jj_la1[0] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
                        topObj.addInnerObject(header);
    }
    tags(topObj);
    jj_consume_token(0);
        {if (true) return topObj;}
    throw new Error("Missing return statement in function");
  }

  final public XmlHeaderTagObject xmlDef() throws ParseException {
        XmlHeaderTagObject tag = new XmlHeaderTagObject();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TAG_BEGIN:
      jj_consume_token(TAG_BEGIN);
      break;
    case STR2TAG:
      jj_consume_token(STR2TAG);
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(QUESTION);
    jj_consume_token(IDENTIFIER);
    attrs(tag);
    jj_consume_token(QUESTION);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public DoctypeTagObject docType() throws ParseException {
        DoctypeTagObject tag = new DoctypeTagObject();
        Token t = null;
        IAttributeValue attrVal = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TAG_BEGIN:
      jj_consume_token(TAG_BEGIN);
      break;
    case STR2TAG:
      jj_consume_token(STR2TAG);
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(DOCTYPE);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case HTML:
      case IDENTIFIER:
      case DQ_END:
      case SQ_END:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case HTML:
        jj_consume_token(HTML);
        break;
      case IDENTIFIER:
        t = jj_consume_token(IDENTIFIER);
        break;
      case DQ_END:
      case SQ_END:
        attrVal = attrValue();
                        if(t != null){
                                tag.addIdentifier(t.image);
                        }
                        if(attrVal != null){
                                tag.addAttribute(attrVal);
                        }
                        t = null;
                        attrVal = null;
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public XMLTagBase tags(XMLTagBase tags) throws ParseException {
        XMLTagBase tmp = null;
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TAG_BEGIN:
      case STR2TAG:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_3;
      }
      tmp = tag(tags);
                               tags.addInnerObject(tmp);
    }
                {if (true) return tmp;}
    throw new Error("Missing return statement in function");
  }

  final public XMLTagBase tag(XMLTagBase parent) throws ParseException {
        XMLTagBase tag = null;
        StringContainer str = null;
        Token str_t = null;
        Token tag_t = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TAG_BEGIN:
      tag_t = jj_consume_token(TAG_BEGIN);
      break;
    case STR2TAG:
      str_t = jj_consume_token(STR2TAG);
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HTML:
      tag = htmlTag();
      break;
    case BODY:
      tag = bodyTag();
      break;
    case TITLE:
      tag = titleTag();
      break;
    case TABLE:
      tag = tableTag();
      break;
    case TR:
      tag = trTag();
      break;
    case TD:
      tag = tdTag();
      break;
    case B:
      tag = bTag();
      break;
    case BR:
      tag = brTag();
      break;
    case H1:
      tag = h1Tag();
      break;
    case H2:
      tag = h2Tag();
      break;
    case H3:
      tag = h3Tag();
      break;
    case P:
      tag = pTag();
      break;
    case IMG:
      tag = imgTag();
      break;
    case A:
      tag = aTag();
      break;
    case META:
      tag = metaTag();
      break;
    case SCRIPT:
      tag = scriptTag();
      break;
    case NOSCRIPT:
      tag = noscriptTag();
      break;
    case FONT:
      tag = fontTag();
      break;
    case DIV:
      tag = divTag();
      break;
    case FORM:
      tag = formTag();
      break;
    case INPUT:
      tag = inputTag();
      break;
    case SELECT:
      tag = selectTag();
      break;
    case OPTGROUP:
      tag = optgroupTag();
      break;
    case OPTION:
      tag = optionTag();
      break;
    case TEXTAREA:
      tag = textareaTag();
      break;
    case LEGEND:
      tag = legendTag();
      break;
    case FIELDSET:
      tag = fieldsetTag();
      break;
    case LABEL:
      tag = labelTag();
      break;
    case BUTTON:
      tag = buttonTag();
      break;
    case LI:
      tag = liTag();
      break;
    case BIG:
      tag = bigTag();
      break;
    case SMALL:
      tag = smallTag();
      break;
    case BLOCKQUOTE:
      tag = blockquoteTag();
      break;
    case HEAD:
      tag = headTag();
      break;
    case TBODY:
      tag = tbodyTag();
      break;
    case CENTER:
      tag = centerTag();
      break;
    case HR:
      tag = hrTag();
      break;
    case LINK:
      tag = linkTag();
      break;
    case SPAN:
      tag = spanTag();
      break;
    case AREA:
      tag = areaTag();
      break;
    case BASE:
      tag = baseTag();
      break;
    case PARAM:
      tag = paramTag();
      break;
    case COL:
      tag = colTag();
      break;
    case CAPTION:
      tag = captionTag();
      break;
    case CITE:
      tag = citeTag();
      break;
    case PRE:
      tag = preTag();
      break;
    case EM:
      tag = emTag();
      break;
    case FRAME:
      tag = frameTag();
      break;
    case FRAMESET:
      tag = framesetTag();
      break;
    case INS:
      tag = insTag();
      break;
    case STYLE:
      tag = styleTag();
      break;
    case TH:
      tag = thTag();
      break;
    case SUP:
      tag = supTag();
      break;
    case SUB:
      tag = subTag();
      break;
    case UL:
      tag = ulTag();
      break;
    case Q:
      tag = qTag();
      break;
    case OL:
      tag = olTag();
      break;
    case MAP:
      tag = mapTag();
      break;
    case I:
      tag = iTag();
      break;
    case H4:
      tag = h4Tag();
      break;
    case H5:
      tag = h5Tag();
      break;
    case H6:
      tag = h6Tag();
      break;
    case DEL:
      tag = delTag();
      break;
    case DL:
      tag = dlTag();
      break;
    case ADDRESS:
      tag = addressTag();
      break;
    case APPLET:
      tag = appletTag();
      break;
    case OBJECT:
      tag = objectTag();
      break;
    case TFOOT:
      tag = tfootTag();
      break;
    case TT:
      tag = ttTag();
      break;
    case THREAD:
      tag = threadTag();
      break;
    case COLGROUP:
      tag = colgroupTag();
      break;
    case BGSOUND:
      tag = bgsoundTag();
      break;
    case IDENTIFIER:
      tag = unknownTag();
      break;
    case COMMENT:
      tag = comment();
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                if(str_t != null){
                        str = new StringContainer();
                        str.setStr(str_t.image);
                        parent.addInnerObject(str);
                }
                else{
                        tag.setLine(tag_t.beginLine);
                        tag.setLinePosition(tag_t.beginColumn);
                }

                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public UnknownTagObject unknownTag() throws ParseException {
        UnknownTagObject tag = new UnknownTagObject();
        String tagName = null;
    tagName = unknownTagIdentifier();
    attrs(tag);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HTML_TAG_END:
      jj_consume_token(HTML_TAG_END);
      tags(tag);
      endTag(tag);
      unknownTagIdentifier();
      jj_consume_token(HTML_TAG_END);
      break;
    case XML_TAG_END:
      jj_consume_token(XML_TAG_END);
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                tag.setTagName(tagName);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public String unknownTagIdentifier() throws ParseException {
        StringBuffer sb = new StringBuffer();
        String str = null;
        Token t = null;
    t = jj_consume_token(IDENTIFIER);
                sb.append(t.image);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLON:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_4;
      }
      jj_consume_token(COLON);
      str = attrIdentifierElement();
                        sb.append(":");
                        sb.append(str);
    }
                {if (true) return sb.toString();}
    throw new Error("Missing return statement in function");
  }

  final public void endTag(XMLTagBase parent) throws ParseException {
        StringContainer str = null;
        Token str_t = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TAG_END_BEGIN:
      jj_consume_token(TAG_END_BEGIN);
      break;
    case STR2TAG_END_BEGIN:
      str_t = jj_consume_token(STR2TAG_END_BEGIN);
                if(str_t != null){
                        str = new StringContainer();
                        str.setStr(str_t.image);
                        parent.addInnerObject(str);
                }
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void attrs(XMLTagBase tag) throws ParseException {
        Attribute at = null;
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case HTML:
      case TITLE:
      case BODY:
      case TABLE:
      case TR:
      case TD:
      case B:
      case BR:
      case H1:
      case H2:
      case H3:
      case P:
      case IMG:
      case A:
      case META:
      case NOSCRIPT:
      case FONT:
      case DIV:
      case FORM:
      case INPUT:
      case SELECT:
      case OPTGROUP:
      case OPTION:
      case TEXTAREA:
      case LEGEND:
      case FIELDSET:
      case LABEL:
      case BUTTON:
      case LI:
      case BIG:
      case SMALL:
      case BLOCKQUOTE:
      case HEAD:
      case TBODY:
      case CENTER:
      case HR:
      case LINK:
      case SPAN:
      case AREA:
      case BASE:
      case PARAM:
      case COL:
      case CAPTION:
      case CITE:
      case PRE:
      case EM:
      case FRAME:
      case FRAMESET:
      case INS:
      case STYLE:
      case TH:
      case SUP:
      case SUB:
      case UL:
      case Q:
      case OL:
      case MAP:
      case I:
      case H4:
      case H5:
      case H6:
      case DEL:
      case DL:
      case ADDRESS:
      case APPLET:
      case OBJECT:
      case TFOOT:
      case TT:
      case THREAD:
      case COLGROUP:
      case CHECKED:
      case SELECTED:
      case UTN:
      case AUTOFOCUS:
      case SCRIPT:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[11] = jj_gen;
        break label_5;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case HTML:
      case TITLE:
      case BODY:
      case TABLE:
      case TR:
      case TD:
      case B:
      case BR:
      case H1:
      case H2:
      case H3:
      case P:
      case IMG:
      case A:
      case META:
      case NOSCRIPT:
      case FONT:
      case DIV:
      case FORM:
      case INPUT:
      case SELECT:
      case OPTGROUP:
      case OPTION:
      case TEXTAREA:
      case LEGEND:
      case FIELDSET:
      case LABEL:
      case BUTTON:
      case LI:
      case BIG:
      case SMALL:
      case BLOCKQUOTE:
      case HEAD:
      case TBODY:
      case CENTER:
      case HR:
      case LINK:
      case SPAN:
      case AREA:
      case BASE:
      case PARAM:
      case COL:
      case CAPTION:
      case CITE:
      case PRE:
      case EM:
      case FRAME:
      case FRAMESET:
      case INS:
      case STYLE:
      case TH:
      case SUP:
      case SUB:
      case UL:
      case Q:
      case OL:
      case MAP:
      case I:
      case H4:
      case H5:
      case H6:
      case DEL:
      case DL:
      case ADDRESS:
      case APPLET:
      case OBJECT:
      case TFOOT:
      case TT:
      case THREAD:
      case COLGROUP:
      case SCRIPT:
      case IDENTIFIER:
        at = attr();
                        tag.putAttribute(at.getKey(), at.getValue());
        break;
      case CHECKED:
      case SELECTED:
      case UTN:
      case AUTOFOCUS:
        at = singleAttr();
                        tag.putAttribute(at.getKey(), at.getValue());
        break;
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public Attribute singleAttr() throws ParseException {
        Attribute attr = new Attribute();
        Token t = null;
        IAttributeValue val = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHECKED:
      t = jj_consume_token(CHECKED);
      break;
    case SELECTED:
      t = jj_consume_token(SELECTED);
      break;
    case UTN:
      t = jj_consume_token(UTN);
      break;
    case AUTOFOCUS:
      t = jj_consume_token(AUTOFOCUS);
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUALS:
      jj_consume_token(EQUALS);
      val = attrValue();
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
                attr.setKey(t.image);
                attr.setValue(val);

                {if (true) return attr;}
    throw new Error("Missing return statement in function");
  }

  final public Attribute attr() throws ParseException {
        Attribute attr = new Attribute();
        String id;
        IAttributeValue val = null;
    id = attrIdentifier();
    jj_consume_token(EQUALS);
    val = attrValue();
                attr.setKey(id);
                attr.setValue(val);
                {if (true) return attr;}
    throw new Error("Missing return statement in function");
  }

  final public String attrIdentifier() throws ParseException {
        StringBuffer sb = new StringBuffer();
        String str = null;
    str = attrIdentifierElement();
                sb.append(str);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLON:
        ;
        break;
      default:
        jj_la1[15] = jj_gen;
        break label_6;
      }
      jj_consume_token(COLON);
      str = attrIdentifierElement();
                        sb.append(":");
                        sb.append(str);
    }
                {if (true) return sb.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String attrIdentifierElement() throws ParseException {
        Token t1 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      t1 = jj_consume_token(IDENTIFIER);
      break;
    case FORM:
      t1 = jj_consume_token(FORM);
      break;
    case STYLE:
      t1 = jj_consume_token(STYLE);
      break;
    case HTML:
      t1 = jj_consume_token(HTML);
      break;
    case TITLE:
      t1 = jj_consume_token(TITLE);
      break;
    case BODY:
      t1 = jj_consume_token(BODY);
      break;
    case TABLE:
      t1 = jj_consume_token(TABLE);
      break;
    case TR:
      t1 = jj_consume_token(TR);
      break;
    case TD:
      t1 = jj_consume_token(TD);
      break;
    case B:
      t1 = jj_consume_token(B);
      break;
    case BR:
      t1 = jj_consume_token(BR);
      break;
    case H1:
      t1 = jj_consume_token(H1);
      break;
    case H2:
      t1 = jj_consume_token(H2);
      break;
    case H3:
      t1 = jj_consume_token(H3);
      break;
    case P:
      t1 = jj_consume_token(P);
      break;
    case IMG:
      t1 = jj_consume_token(IMG);
      break;
    case A:
      t1 = jj_consume_token(A);
      break;
    case META:
      t1 = jj_consume_token(META);
      break;
    case SCRIPT:
      t1 = jj_consume_token(SCRIPT);
      break;
    case NOSCRIPT:
      t1 = jj_consume_token(NOSCRIPT);
      break;
    case FONT:
      t1 = jj_consume_token(FONT);
      break;
    case DIV:
      t1 = jj_consume_token(DIV);
      break;
    case INPUT:
      t1 = jj_consume_token(INPUT);
      break;
    case SELECT:
      t1 = jj_consume_token(SELECT);
      break;
    case OPTGROUP:
      t1 = jj_consume_token(OPTGROUP);
      break;
    case OPTION:
      t1 = jj_consume_token(OPTION);
      break;
    case TEXTAREA:
      t1 = jj_consume_token(TEXTAREA);
      break;
    case LEGEND:
      t1 = jj_consume_token(LEGEND);
      break;
    case FIELDSET:
      t1 = jj_consume_token(FIELDSET);
      break;
    case LABEL:
      t1 = jj_consume_token(LABEL);
      break;
    case BUTTON:
      t1 = jj_consume_token(BUTTON);
      break;
    case LI:
      t1 = jj_consume_token(LI);
      break;
    case BIG:
      t1 = jj_consume_token(BIG);
      break;
    case SMALL:
      t1 = jj_consume_token(SMALL);
      break;
    case BLOCKQUOTE:
      t1 = jj_consume_token(BLOCKQUOTE);
      break;
    case HEAD:
      t1 = jj_consume_token(HEAD);
      break;
    case TBODY:
      t1 = jj_consume_token(TBODY);
      break;
    case CENTER:
      t1 = jj_consume_token(CENTER);
      break;
    case HR:
      t1 = jj_consume_token(HR);
      break;
    case LINK:
      t1 = jj_consume_token(LINK);
      break;
    case SPAN:
      t1 = jj_consume_token(SPAN);
      break;
    case AREA:
      t1 = jj_consume_token(AREA);
      break;
    case BASE:
      t1 = jj_consume_token(BASE);
      break;
    case PARAM:
      t1 = jj_consume_token(PARAM);
      break;
    case COL:
      t1 = jj_consume_token(COL);
      break;
    case CAPTION:
      t1 = jj_consume_token(CAPTION);
      break;
    case CITE:
      t1 = jj_consume_token(CITE);
      break;
    case PRE:
      t1 = jj_consume_token(PRE);
      break;
    case EM:
      t1 = jj_consume_token(EM);
      break;
    case FRAME:
      t1 = jj_consume_token(FRAME);
      break;
    case FRAMESET:
      t1 = jj_consume_token(FRAMESET);
      break;
    case INS:
      t1 = jj_consume_token(INS);
      break;
    case TH:
      t1 = jj_consume_token(TH);
      break;
    case SUP:
      t1 = jj_consume_token(SUP);
      break;
    case SUB:
      t1 = jj_consume_token(SUB);
      break;
    case UL:
      t1 = jj_consume_token(UL);
      break;
    case Q:
      t1 = jj_consume_token(Q);
      break;
    case OL:
      t1 = jj_consume_token(OL);
      break;
    case MAP:
      t1 = jj_consume_token(MAP);
      break;
    case I:
      t1 = jj_consume_token(I);
      break;
    case H4:
      t1 = jj_consume_token(H4);
      break;
    case H5:
      t1 = jj_consume_token(H5);
      break;
    case H6:
      t1 = jj_consume_token(H6);
      break;
    case DEL:
      t1 = jj_consume_token(DEL);
      break;
    case DL:
      t1 = jj_consume_token(DL);
      break;
    case ADDRESS:
      t1 = jj_consume_token(ADDRESS);
      break;
    case APPLET:
      t1 = jj_consume_token(APPLET);
      break;
    case OBJECT:
      t1 = jj_consume_token(OBJECT);
      break;
    case TFOOT:
      t1 = jj_consume_token(TFOOT);
      break;
    case TT:
      t1 = jj_consume_token(TT);
      break;
    case THREAD:
      t1 = jj_consume_token(THREAD);
      break;
    case COLGROUP:
      t1 = jj_consume_token(COLGROUP);
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return t1.image;}
    throw new Error("Missing return statement in function");
  }

  final public IAttributeValue attrValue() throws ParseException {
        Token t1 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DQ_END:
      t1 = jj_consume_token(DQ_END);
                     {if (true) return new DqString(t1.image);}
      break;
    case SQ_END:
      t1 = jj_consume_token(SQ_END);
                       {if (true) return new SqString(t1.image);}
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public HtmlTagObject htmlTag() throws ParseException {
        HtmlTagObject htmlTag = new HtmlTagObject();
    jj_consume_token(HTML);
    attrs(htmlTag);
    jj_consume_token(HTML_TAG_END);
    tags(htmlTag);
    endTag(htmlTag);
    jj_consume_token(HTML);
    jj_consume_token(HTML_TAG_END);
                {if (true) return htmlTag;}
    throw new Error("Missing return statement in function");
  }

  final public BodyTagObject bodyTag() throws ParseException {
        BodyTagObject tagBody = new BodyTagObject();
    jj_consume_token(BODY);
    attrs(tagBody);
    jj_consume_token(HTML_TAG_END);
    tags(tagBody);
    endTag(tagBody);
    jj_consume_token(BODY);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tagBody;}
    throw new Error("Missing return statement in function");
  }

  final public TitleTag titleTag() throws ParseException {
        TitleTag _titleTag = new TitleTag();
    jj_consume_token(TITLE);
    attrs(_titleTag);
    jj_consume_token(HTML_TAG_END);
    tags(_titleTag);
    endTag(_titleTag);
    jj_consume_token(TITLE);
    jj_consume_token(HTML_TAG_END);
                {if (true) return _titleTag;}
    throw new Error("Missing return statement in function");
  }

  final public TableTagObject tableTag() throws ParseException {
        TableTagObject tableTag = new TableTagObject();
    jj_consume_token(TABLE);
    attrs(tableTag);
    jj_consume_token(HTML_TAG_END);
    tags(tableTag);
    endTag(tableTag);
    jj_consume_token(TABLE);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tableTag;}
    throw new Error("Missing return statement in function");
  }

  final public TrTagObject trTag() throws ParseException {
        TrTagObject trTag = new TrTagObject();
    jj_consume_token(TR);
    attrs(trTag);
    jj_consume_token(HTML_TAG_END);
    tags(trTag);
    endTag(trTag);
    jj_consume_token(TR);
    jj_consume_token(HTML_TAG_END);
                {if (true) return trTag;}
    throw new Error("Missing return statement in function");
  }

  final public TdTagObject tdTag() throws ParseException {
        TdTagObject tdTag = new TdTagObject();
    jj_consume_token(TD);
    attrs(tdTag);
    jj_consume_token(HTML_TAG_END);
    tags(tdTag);
    endTag(tdTag);
    jj_consume_token(TD);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tdTag;}
    throw new Error("Missing return statement in function");
  }

  final public BTagObject bTag() throws ParseException {
        BTagObject bTag = new BTagObject();
    jj_consume_token(B);
    attrs(bTag);
    jj_consume_token(HTML_TAG_END);
    tags(bTag);
    endTag(bTag);
    jj_consume_token(B);
    jj_consume_token(HTML_TAG_END);
                {if (true) return bTag;}
    throw new Error("Missing return statement in function");
  }

  final public BrTagObject brTag() throws ParseException {
        BrTagObject brTag = new BrTagObject();
    jj_consume_token(BR);
    attrs(brTag);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HTML_TAG_END:
      jj_consume_token(HTML_TAG_END);
      break;
    case XML_TAG_END:
      jj_consume_token(XML_TAG_END);
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return brTag;}
    throw new Error("Missing return statement in function");
  }

  final public H1TagObject h1Tag() throws ParseException {
        H1TagObject h1Tag = new H1TagObject();
    jj_consume_token(H1);
    attrs(h1Tag);
    jj_consume_token(HTML_TAG_END);
    tags(h1Tag);
    endTag(h1Tag);
    jj_consume_token(H1);
    jj_consume_token(HTML_TAG_END);
                {if (true) return h1Tag;}
    throw new Error("Missing return statement in function");
  }

  final public H2TagObject h2Tag() throws ParseException {
        H2TagObject h2Tag = new H2TagObject();
    jj_consume_token(H2);
    attrs(h2Tag);
    jj_consume_token(HTML_TAG_END);
    tags(h2Tag);
    endTag(h2Tag);
    jj_consume_token(H2);
    jj_consume_token(HTML_TAG_END);
                {if (true) return h2Tag;}
    throw new Error("Missing return statement in function");
  }

  final public H3TagObject h3Tag() throws ParseException {
        H3TagObject h3Tag = new H3TagObject();
    jj_consume_token(H3);
    attrs(h3Tag);
    jj_consume_token(HTML_TAG_END);
    tags(h3Tag);
    endTag(h3Tag);
    jj_consume_token(H3);
    jj_consume_token(HTML_TAG_END);
                {if (true) return h3Tag;}
    throw new Error("Missing return statement in function");
  }

  final public PTagObject pTag() throws ParseException {
        PTagObject pTag = new PTagObject();
    jj_consume_token(P);
    attrs(pTag);
    jj_consume_token(HTML_TAG_END);
    tags(pTag);
    endTag(pTag);
    jj_consume_token(P);
    jj_consume_token(HTML_TAG_END);
                {if (true) return pTag;}
    throw new Error("Missing return statement in function");
  }

  final public ImgTagObject imgTag() throws ParseException {
        ImgTagObject tag = new ImgTagObject();
    jj_consume_token(IMG);
    attrs(tag);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HTML_TAG_END:
      jj_consume_token(HTML_TAG_END);
      break;
    case XML_TAG_END:
      jj_consume_token(XML_TAG_END);
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public ATagObject aTag() throws ParseException {
        ATagObject tag = new ATagObject();
    jj_consume_token(A);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(A);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public MetaTagObject metaTag() throws ParseException {
        MetaTagObject tag = new MetaTagObject();
    jj_consume_token(META);
    attrs(tag);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HTML_TAG_END:
      jj_consume_token(HTML_TAG_END);
      break;
    case XML_TAG_END:
      jj_consume_token(XML_TAG_END);
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public ScriptTagObject scriptTag() throws ParseException {
        ScriptTagObject tag = new ScriptTagObject();
    jj_consume_token(SCRIPT);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(SCRIPT);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public NoscriptTagObject noscriptTag() throws ParseException {
        NoscriptTagObject tag = new NoscriptTagObject();
    jj_consume_token(NOSCRIPT);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(NOSCRIPT);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public FontTagObject fontTag() throws ParseException {
        FontTagObject tag = new FontTagObject();
    jj_consume_token(FONT);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(FONT);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public DivTagObject divTag() throws ParseException {
        DivTagObject tag = new DivTagObject();
    jj_consume_token(DIV);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(DIV);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public FormTagObject formTag() throws ParseException {
        FormTagObject tag = new FormTagObject();
    jj_consume_token(FORM);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(FORM);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public InputTagObject inputTag() throws ParseException {
        InputTagObject tag = new InputTagObject();
    jj_consume_token(INPUT);
    attrs(tag);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HTML_TAG_END:
      jj_consume_token(HTML_TAG_END);
      break;
    case XML_TAG_END:
      jj_consume_token(XML_TAG_END);
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public SelectTagObject selectTag() throws ParseException {
        SelectTagObject tag = new SelectTagObject();
    jj_consume_token(SELECT);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(SELECT);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public OptgroupTagObject optgroupTag() throws ParseException {
        OptgroupTagObject tag = new OptgroupTagObject();
    jj_consume_token(OPTGROUP);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(OPTGROUP);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public OptionTagObject optionTag() throws ParseException {
        OptionTagObject tag = new OptionTagObject();
    jj_consume_token(OPTION);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(OPTION);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public TextAreaTagObject textareaTag() throws ParseException {
        TextAreaTagObject tag = new TextAreaTagObject();
    jj_consume_token(TEXTAREA);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(TEXTAREA);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public LegendTagObject legendTag() throws ParseException {
        LegendTagObject tag = new LegendTagObject();
    jj_consume_token(LEGEND);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(LEGEND);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public FieldsetTagObject fieldsetTag() throws ParseException {
        FieldsetTagObject tag = new FieldsetTagObject();
    jj_consume_token(FIELDSET);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(FIELDSET);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public LabelTagObject labelTag() throws ParseException {
        LabelTagObject tag = new LabelTagObject();
    jj_consume_token(LABEL);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(LABEL);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public ButtonTagObject buttonTag() throws ParseException {
        ButtonTagObject tag = new ButtonTagObject();
    jj_consume_token(BUTTON);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(BUTTON);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public CommentObject comment() throws ParseException {
        CommentObject comm = new CommentObject();
        Token t = null;
    t = jj_consume_token(COMMENT);
                comm.setCommentStr(t.image);
                {if (true) return comm;}
    throw new Error("Missing return statement in function");
  }

  final public LiTagObject liTag() throws ParseException {
        LiTagObject tag = new LiTagObject();
    jj_consume_token(LI);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(LI);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public BigTagObject bigTag() throws ParseException {
        BigTagObject tag = new BigTagObject();
    jj_consume_token(BIG);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(BIG);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public SmallTagObject smallTag() throws ParseException {
        SmallTagObject tag = new SmallTagObject();
    jj_consume_token(SMALL);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(SMALL);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public BlockquoteTagObject blockquoteTag() throws ParseException {
        BlockquoteTagObject tag = new BlockquoteTagObject();
    jj_consume_token(BLOCKQUOTE);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(BLOCKQUOTE);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public HeadTagObject headTag() throws ParseException {
        HeadTagObject tag = new HeadTagObject();
    jj_consume_token(HEAD);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(HEAD);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public TBodyTagObject tbodyTag() throws ParseException {
        TBodyTagObject tag = new TBodyTagObject();
    jj_consume_token(TBODY);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(TBODY);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public CenterTagObject centerTag() throws ParseException {
        CenterTagObject tag = new CenterTagObject();
    jj_consume_token(CENTER);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(CENTER);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public HrTagObject hrTag() throws ParseException {
        HrTagObject tag = new HrTagObject();
    jj_consume_token(HR);
    attrs(tag);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HTML_TAG_END:
      jj_consume_token(HTML_TAG_END);
      break;
    case XML_TAG_END:
      jj_consume_token(XML_TAG_END);
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public LinkTagObject linkTag() throws ParseException {
        LinkTagObject tag = new LinkTagObject();
    jj_consume_token(LINK);
    attrs(tag);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HTML_TAG_END:
      jj_consume_token(HTML_TAG_END);
      break;
    case XML_TAG_END:
      jj_consume_token(XML_TAG_END);
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public SpanTagObject spanTag() throws ParseException {
        SpanTagObject tag = new SpanTagObject();
    jj_consume_token(SPAN);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(SPAN);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public AreaTagObject areaTag() throws ParseException {
        AreaTagObject tag = new AreaTagObject();
    jj_consume_token(AREA);
    attrs(tag);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HTML_TAG_END:
      jj_consume_token(HTML_TAG_END);
      break;
    case XML_TAG_END:
      jj_consume_token(XML_TAG_END);
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public BaseTagObject baseTag() throws ParseException {
        BaseTagObject tag = new BaseTagObject();
    jj_consume_token(BASE);
    attrs(tag);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HTML_TAG_END:
      jj_consume_token(HTML_TAG_END);
      break;
    case XML_TAG_END:
      jj_consume_token(XML_TAG_END);
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public ParamTagObject paramTag() throws ParseException {
        ParamTagObject tag = new ParamTagObject();
    jj_consume_token(PARAM);
    attrs(tag);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HTML_TAG_END:
      jj_consume_token(HTML_TAG_END);
      break;
    case XML_TAG_END:
      jj_consume_token(XML_TAG_END);
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public ColTagObject colTag() throws ParseException {
        ColTagObject tag = new ColTagObject();
    jj_consume_token(COL);
    attrs(tag);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HTML_TAG_END:
      jj_consume_token(HTML_TAG_END);
      break;
    case XML_TAG_END:
      jj_consume_token(XML_TAG_END);
      break;
    default:
      jj_la1[27] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public CaptionTagObject captionTag() throws ParseException {
        CaptionTagObject tag = new CaptionTagObject();
    jj_consume_token(CAPTION);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(CAPTION);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public CiteTagObject citeTag() throws ParseException {
        CiteTagObject tag = new CiteTagObject();
    jj_consume_token(CITE);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(CITE);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public PreTagObject preTag() throws ParseException {
        PreTagObject tag = new PreTagObject();
    jj_consume_token(PRE);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(PRE);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public EmTagObject emTag() throws ParseException {
        EmTagObject tag = new EmTagObject();
    jj_consume_token(EM);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(EM);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public FrameTagObject frameTag() throws ParseException {
        FrameTagObject tag = new FrameTagObject();
    jj_consume_token(FRAME);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(FRAME);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public FramesetTagObject framesetTag() throws ParseException {
        FramesetTagObject tag = new FramesetTagObject();
    jj_consume_token(FRAMESET);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(FRAMESET);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public InsTagObject insTag() throws ParseException {
        InsTagObject tag = new InsTagObject();
    jj_consume_token(INS);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(INS);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public StyleTagObject styleTag() throws ParseException {
        StyleTagObject tag = new StyleTagObject();
    jj_consume_token(STYLE);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(STYLE);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public ThTagObject thTag() throws ParseException {
        ThTagObject tag = new ThTagObject();
    jj_consume_token(TH);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(TH);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public SupTagObject supTag() throws ParseException {
        SupTagObject tag = new SupTagObject();
    jj_consume_token(SUP);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(SUP);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public SubTagObject subTag() throws ParseException {
        SubTagObject tag = new SubTagObject();
    jj_consume_token(SUB);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(SUB);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public UlTagObject ulTag() throws ParseException {
        UlTagObject tag = new UlTagObject();
    jj_consume_token(UL);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(UL);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public QTagObject qTag() throws ParseException {
        QTagObject tag = new QTagObject();
    jj_consume_token(Q);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(Q);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public OlTagObject olTag() throws ParseException {
        OlTagObject tag = new OlTagObject();
    jj_consume_token(OL);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(OL);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public MapTagObject mapTag() throws ParseException {
        MapTagObject tag = new MapTagObject();
    jj_consume_token(MAP);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(MAP);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public ITagObject iTag() throws ParseException {
        ITagObject tag = new ITagObject();
    jj_consume_token(I);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(I);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public H4TagObject h4Tag() throws ParseException {
        H4TagObject tag = new H4TagObject();
    jj_consume_token(H4);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(H4);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public H5TagObject h5Tag() throws ParseException {
        H5TagObject tag = new H5TagObject();
    jj_consume_token(H5);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(H5);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public H6TagObject h6Tag() throws ParseException {
        H6TagObject tag = new H6TagObject();
    jj_consume_token(H6);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(H6);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public DelTagObject delTag() throws ParseException {
        DelTagObject tag = new DelTagObject();
    jj_consume_token(DEL);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(DEL);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public DlTagObject dlTag() throws ParseException {
        DlTagObject tag = new DlTagObject();
    jj_consume_token(DL);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(DL);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public AddressTagObject addressTag() throws ParseException {
        AddressTagObject tag = new AddressTagObject();
    jj_consume_token(ADDRESS);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(ADDRESS);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public AppletTagObject appletTag() throws ParseException {
        AppletTagObject tag = new AppletTagObject();
    jj_consume_token(APPLET);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(APPLET);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public ObjectTagObject objectTag() throws ParseException {
        ObjectTagObject tag = new ObjectTagObject();
    jj_consume_token(OBJECT);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(OBJECT);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public TfootTagObject tfootTag() throws ParseException {
        TfootTagObject tag = new TfootTagObject();
    jj_consume_token(TFOOT);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(TFOOT);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public TtTagObject ttTag() throws ParseException {
        TtTagObject tag = new TtTagObject();
    jj_consume_token(TT);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(TT);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public ThreadTagObject threadTag() throws ParseException {
        ThreadTagObject tag = new ThreadTagObject();
    jj_consume_token(THREAD);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(THREAD);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public ColgroupTagObject colgroupTag() throws ParseException {
        ColgroupTagObject tag = new ColgroupTagObject();
    jj_consume_token(COLGROUP);
    attrs(tag);
    jj_consume_token(HTML_TAG_END);
    tags(tag);
    endTag(tag);
    jj_consume_token(COLGROUP);
    jj_consume_token(HTML_TAG_END);
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final public BgSoundObject bgsoundTag() throws ParseException {
        BgSoundObject tag = new BgSoundObject();
    jj_consume_token(BGSOUND);
    attrs(tag);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HTML_TAG_END:
      jj_consume_token(HTML_TAG_END);
      break;
    case XML_TAG_END:
      jj_consume_token(XML_TAG_END);
      break;
    default:
      jj_la1[28] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return tag;}
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_3R_8() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(6)) {
    jj_scanpos = xsp;
    if (jj_scan_token(109)) return true;
    }
    if (jj_scan_token(DOCTYPE)) return true;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_3R_8()) return true;
    return false;
  }

  final private boolean jj_3R_7() {
    if (jj_3R_9()) return true;
    return false;
  }

  final private boolean jj_3R_9() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(6)) {
    jj_scanpos = xsp;
    if (jj_scan_token(109)) return true;
    }
    if (jj_scan_token(QUESTION)) return true;
    return false;
  }

  final private boolean jj_3_1() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_2()) {
    jj_scanpos = xsp;
    if (jj_3R_7()) return true;
    }
    return false;
  }

  public AlinousObjectParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private int jj_gen;
  final private int[] jj_la1 = new int[29];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
      jj_la1_3();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x40,0x40,0x40,0x2000,0x2000,0x40,0x40,0xffffe000,0x0,0x0,0x80,0xffffe000,0xffffe000,0x0,0x0,0x0,0xffffe000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0xffffffff,0xffffffff,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x10000000,0x10000000,0x0,0x0,0x110fffff,0x0,0x8000000,0x0,0x11f7ffff,0x11f7ffff,0xf00000,0x4000000,0x8000000,0x1107ffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_3() {
      jj_la1_3 = new int[] {0x2000,0x2000,0x2000,0x480,0x480,0x2000,0x2000,0x20,0x3,0x0,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x480,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[2];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public AlinousObjectParser(java.io.InputStream stream) {
     this(stream, null);
  }
  public AlinousObjectParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new AlinousObjectParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public AlinousObjectParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new AlinousObjectParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public AlinousObjectParser(AlinousObjectParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(AlinousObjectParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error {

	/**
	 * 
	 */
	private static final long serialVersionUID = -1541245574759259336L; }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }


private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  @SuppressWarnings("unchecked")
private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  @SuppressWarnings("unchecked")
public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[113];
    for (int i = 0; i < 113; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 29; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 113; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 2; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
